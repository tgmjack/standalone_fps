
<!DOCTYPE html>

<!--

to do
1 radar legend
2 longer reach for door



1) make so maps can be asymetric (i think ive mixed up width n height somewhere) (done) (not done)

5) point to static propperly
{% load static %}
<img src='static/my_app/example.jpg' alt="My image">

6)  enemies
attack animations / being shot animation

7) more weapons (shotgun), better drawing for mg in hand

11) fix random imortal enemy (is it even still a thing?) (might be fixed)

notes
enemy speed has to be significantly less than path finding step size

-->

<html lang="en" dir="ltr">
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.3.3/math.js"></script>
    <meta charset="utf-8">
    <title></title>
  </head>

  <body style = "background-color: #cccccc;">
    <div class="container-fluid" style=" padding:1vw;">
      <div class="row" id = "screen and radar row" style="height: 50vh; width: 70vw;">
        <div class="col" style = "position: relative;  width:100%; height:100%; padding:0px;">
          <canvas id="main_screen" style = "position: relative; left: 0px; float:left;  top: 0px; border-style: solid; width:100%; height:100%;"></canvas>
        </div>
        <div class="col" style = "position: relative;  width:100%; height:100%; padding:0px;">
          <canvas id="canvas_raycasting_radar" style = "position: relative; left: 0px; float:left;  top: 0px; border-style: solid; width:100%; height:100%;"></canvas>
        </div>
      </div>

      <div class="row" id = "hud row" style = "background-color: white;  width: 70vw;">
  <!--        <div id = "hud" style="position:relative; top:0px; width:1005px; height:105px; border-style: solid; background-color: white;">    -->
          <div class = "col" style="border-style: solid;">
            <div id = "health_image" style="float:left;"> <img src='static/health_hud.png' alt="health image" style="float:left;"></div><div id = "health"  style="width:6rem;  height:2rem; border-style: solid; float:left;"></div>
          </div>
 <!--     <div class = "col">
            <div id = "ammo" style="float:left;"></div>
          </div>  -->
          <div class = "col"  style="border-style: solid;">
            <div id = "pistol_image" style="float:left;"> <img src='static/pistol_hud.png' alt="pistol image" style="float:left;"> </div><div id = "pistol_ammo" style="width:6rem; height:2rem; border-style: solid; float:left;"></div>
          </div>
          <div class = "col" style="border-style: solid;">
            <div id = "mg_image" style="float:left;">   <img src='static/mg_hud.png' alt="mg image" style="float:left;"></div> <div id = "mg_ammo" style="width:6rem;  height:2rem; border-style: solid; float:left;"></div>
          </div>
          <div class = "col" style="border-style: solid;">
            <div id = "shotty_image" style="float:left;">   <img src='static/shotty_hud.png' alt="shotty image" style="float:left;"></div> <div id = "shotty_ammo" style="width:6rem;  height:2rem; border-style: solid; float:left;"></div>
          </div>
          <div class = "col" style="border-style: solid;">
            <div id="score"  style="position:relative; left:50px; " > <h3 > score </h3> <br> <div id = "the score"> 0 </div> </div>
          </div>
      </div>

      <div class = "row" id = "text" style = "background-color: white; border-style: solid; width: 70vw;">
          <div class="col">
            <div id = "instructions">
              <ul> <h3> instructions </h3> <li>w/s = forwards/backwards      &nbsp; &nbsp; &nbsp; &nbsp; </li><li>a/d = turn left/right</li> <li>q/e = strafe</li>  <li>space = open door</li>  </ul>
            </div>
          </div>
          <div class="col">
            <div id = "instructions">
              <ul>  <li>z = shoot</li>  <li >  numbers = select_weapons  <br> 1 = pistol <br> 2 = mg  <br> 3 = shotgun </li>   </ul>
            </div>
          </div>
          <div class="col" style = " padding:0px;">
            <div id = "notes"  style = "background-color: white;  border-style: solid;">
              <ul> <h3> notes </h3> <li> most art made in paint, (you can probably tell)  </li> <li> all coded in js from scratch (no 3d graphics packages) i wanted to code an fps with no tools to do things for me  </li> </ul>
            </div>
          </div>
      </div>
    </div>

    <div id = "game over" style = "display:none;  position:absolute; left:300px; top:150px; background-color: cyan;">
      <h2> you died </h2>
      <button type="button" onclick="reset()">reset</button>
    </div>


  </body>
  <script type="text/javascript">
    score = document.getElementById("the score");
    hud_health = document.getElementById("health");
    game_over_div = document.getElementById("game over");
    hud_pistol = document.getElementById("pistol_ammo");
    hud_mg = document.getElementById("mg_ammo");
    hud_shotty = document.getElementById("shotty_ammo");
    hud_pistol_img = document.getElementById("pistol_image");
    hud_mg_img = document.getElementById("mg_image");
    hud_shotty_img = document.getElementById("shotty_image");
    radar_canvas = document.getElementById("canvas_raycasting_radar");
    radar_ctx = radar_canvas.getContext("2d");
    main_screen = document.getElementById("main_screen");
    screen_ctx = main_screen.getContext("2d");



    var testing_bool = 0;
    var shooting = 0;
    var gun_fire_counter = 0;
    var a_key_pressed = 0;
    var keycode_pressed = "none";
    var enemy_id_counter = 0
    var pickup_id_counter = 0
    var door_object_id_counter = 0;


    var FOV = Math.PI / 3
    var HALF_FOV = FOV / 2
    var NUM_RAYS = 100
    var MAX_DEPTH = 6
    var DELTA_ANGLE = FOV / NUM_RAYS
    var SCREEN_DIST = main_screen.width / 2 / math.tan(HALF_FOV)
    var SCALE = math.floor(main_screen.width / NUM_RAYS)

    var TEXTURE_SIZE = 500
    var HALF_TEXTURE_SIZE = TEXTURE_SIZE / 2



    var stuff_to_draw_this_frame = []
    var dt =0.01
    var pickup_object_index_counter = 0
    var out_of_ammo_bool = 0

    var number_of_times_space_pressed = 0

    var images_loaded = 0
    var num_of_images = 42;

    var zombie_idle = new Image();
    var zombie_walk_1 = new Image();
    var zombie_walk_2 = new Image();
    var zombie_walk_3 = new Image();
    var zombie_walk_4 = new Image();
    var zombie_walk_5 = new Image();
    var zombie_walk_6 = new Image();
    var zombie_walk_7 = new Image();
    var zombie_walk_8 = new Image();
    var zombie_walk_9 = new Image();
// was 9 now 17

    var zombie_walk_10 = new Image();
    var zombie_walk_11 = new Image();
    var zombie_walk_12 = new Image();
    var zombie_walk_13 = new Image();
    var zombie_walk_14 = new Image();
    var zombie_walk_15 = new Image();
    var zombie_walk_16 = new Image();
    var zombie_walk_17 = new Image();



    var tough_zombie_idle = new Image();
    var tough_zombie_walk_1 = new Image();
    var tough_zombie_walk_2 = new Image();
    var tough_zombie_walk_3 = new Image();
    var tough_zombie_walk_4 = new Image();
    var tough_zombie_walk_5 = new Image();
    var tough_zombie_walk_6 = new Image();
    var tough_zombie_walk_7 = new Image();
    var tough_zombie_walk_8 = new Image();
    var tough_zombie_walk_9 = new Image();
// was 9 now 17

    var tough_zombie_walk_10 = new Image();
    var tough_zombie_walk_11 = new Image();
    var tough_zombie_walk_12 = new Image();
    var tough_zombie_walk_13 = new Image();
    var tough_zombie_walk_14 = new Image();
    var tough_zombie_walk_15 = new Image();
    var tough_zombie_walk_16 = new Image();
    var tough_zombie_walk_17 = new Image();


    var gun_img = new Image();
    var floor_mg_image = new Image();
    var pistol_img = new Image();
    var shooting_1_pistol_img = new Image();
    var shooting_2_pistol_img = new Image();
    var mg_img = new Image();
    var shooting_1_mg_img = new Image();
    var shooting_2_mg_img = new Image();
    var bricks_texture = new Image();
    var door1_image = new Image();
    var door2_image = new Image();
    var door3_image = new Image();
    var door4_image = new Image();
    var door5_image = new Image();
    var door6_image = new Image();
    var door7_image = new Image();
    var door8_image = new Image();
    var door9_image = new Image();
    var door10_image = new Image();
    var door11_image = new Image();
    var door12_image = new Image();
    var door13_image = new Image();

    var click_img_1 = new Image();
    var click_img_2 = new Image();
    var click_img_3 = new Image();
    var click_img_4 = new Image();

    var points_object_image = new Image();

    click_img_1.src = 'static/click 1.png';
    click_img_2.src = 'static/click 2.png';
    click_img_3.src = 'static/click 3.png';
    click_img_4.src = 'static/click 4.png';
    points_object_image.src = 'static/points_object_alpha.png';
    gun_img = pistol_img

    var pickup_objects = []

    zombie_idle.src = 'static/brand new zombies/alphad/1.png';
    zombie_walk_1.src = 'static/brand new zombies/alphad/1.png';
    zombie_walk_2.src = 'static/brand new zombies/alphad/2.png';
    zombie_walk_3.src = 'static/brand new zombies/alphad/3.png';
    zombie_walk_4.src = 'static/brand new zombies/alphad/4.png';
    zombie_walk_5.src = 'static/brand new zombies/alphad/5.png';
    zombie_walk_6.src = 'static/brand new zombies/alphad/6.png';
    zombie_walk_7.src = 'static/brand new zombies/alphad/7.png';
    zombie_walk_8.src = 'static/brand new zombies/alphad/8.png';
    zombie_walk_9.src = 'static/brand new zombies/alphad/9.png';
    zombie_walk_10.src = 'static/brand new zombies/alphad/10.png';
    zombie_walk_11.src = 'static/brand new zombies/alphad/11.png';
    zombie_walk_12.src = 'static/brand new zombies/alphad/12.png';
    zombie_walk_13.src = 'static/brand new zombies/alphad/13.png';
    zombie_walk_14.src = 'static/brand new zombies/alphad/14.png';
    zombie_walk_15.src = 'static/brand new zombies/alphad/15.png';
    zombie_walk_16.src = 'static/brand new zombies/alphad/16.png';
    zombie_walk_17.src = 'static/brand new zombies/alphad/17.png';


    tough_zombie_idle.src = 'static/brand new zombies/alphad/tough1.png';
    tough_zombie_walk_1.src = 'static/brand new zombies/alphad/tough1.png';
    tough_zombie_walk_2.src = 'static/brand new zombies/alphad/tough2.png';
    tough_zombie_walk_3.src = 'static/brand new zombies/alphad/tough3.png';
    tough_zombie_walk_4.src = 'static/brand new zombies/alphad/tough4.png';
    tough_zombie_walk_5.src = 'static/brand new zombies/alphad/tough5.png';
    tough_zombie_walk_6.src = 'static/brand new zombies/alphad/tough6.png';
    tough_zombie_walk_7.src = 'static/brand new zombies/alphad/tough7.png';
    tough_zombie_walk_8.src = 'static/brand new zombies/alphad/tough8.png';
    tough_zombie_walk_9.src = 'static/brand new zombies/alphad/tough9.png';
    tough_zombie_walk_10.src = 'static/brand new zombies/alphad/tough10.png';
    tough_zombie_walk_11.src = 'static/brand new zombies/alphad/tough11.png';
    tough_zombie_walk_12.src = 'static/brand new zombies/alphad/tough12.png';
    tough_zombie_walk_13.src = 'static/brand new zombies/alphad/tough13.png';
    tough_zombie_walk_14.src = 'static/brand new zombies/alphad/tough14.png';
    tough_zombie_walk_15.src = 'static/brand new zombies/alphad/tough15.png';
    tough_zombie_walk_16.src = 'static/brand new zombies/alphad/tough16.png';
    tough_zombie_walk_17.src = 'static/brand new zombies/alphad/tough17.png';

    pistol_img.src = 'static/pistol hand 2 alpha.png';
    shooting_1_pistol_img.src = 'static/pistol 2 hand 1 shoot 1 alpha.png';
    shooting_2_pistol_img.src = 'static/pistol 2 hand 1 shoot 2 alpha.png';
    mg_img.src = 'static/new mg fps hand alpha.png';
    shooting_1_mg_img.src = 'static/new mg fps hand  shot 1 alpha.png';
    shooting_2_mg_img.src = 'static/new mg fps hand  shot 2 alpha.png';
    bricks_texture.src = 'static/bricks.png';
    floor_mg_image.src = 'static/mg1_alpha.png';

    door1_image.src = 'static/door_alpha.png';
    door2_image.src = 'static/door2_alpha.png';
    door3_image.src = 'static/door3_alpha.png';
    door4_image.src = 'static/door4_alpha.png';
    door5_image.src = 'static/door5_alpha.png';
    door6_image.src = 'static/door6_alpha.png';
    door7_image.src = 'static/door7_alpha.png';
    door8_image.src = 'static/door8_alpha.png';
    door9_image.src = 'static/door9_alpha.png';
    door10_image.src = 'static/door10_alpha.png';
    door11_image.src = 'static/door11_alpha.png';
    door12_image.src = 'static/door12_alpha.png';
    door13_image.src = 'static/door13_alpha.png';



    pistol_img.onload = imageLoaded;
    floor_mg_image.onload = imageLoaded;
    zombie_idle.onload = imageLoaded;
    shooting_1_pistol_img.onload = imageLoaded;
    shooting_2_pistol_img.onload = imageLoaded;
    bricks_texture.onload = imageLoaded;
    mg_img.onload = imageLoaded;
    shooting_1_mg_img.onload = imageLoaded;
    shooting_2_mg_img.onload = imageLoaded;
    points_object_image.onload = imageLoaded;
    click_img_1.onload = imageLoaded;
    click_img_2.onload = imageLoaded;
    click_img_3.onload = imageLoaded;
    click_img_4.onload = imageLoaded;


    door1_image.onload = imageLoaded;
    door2_image.onload = imageLoaded;
    door3_image.onload = imageLoaded;
    door4_image.onload = imageLoaded;
    door5_image.onload = imageLoaded;
    door6_image.onload = imageLoaded;
    door7_image.onload = imageLoaded;
    door8_image.onload = imageLoaded;
    door9_image.onload = imageLoaded;
    door10_image.onload = imageLoaded;
    door11_image.onload = imageLoaded;

    zombie_walk_1.onload = imageLoaded;
    zombie_walk_2.onload = imageLoaded;
    zombie_walk_3.onload = imageLoaded;
    zombie_walk_4.onload = imageLoaded;
    zombie_walk_5.onload = imageLoaded;
    zombie_walk_6.onload = imageLoaded;
    zombie_walk_7.onload = imageLoaded;
    zombie_walk_8.onload = imageLoaded;
    zombie_walk_9.onload = imageLoaded;
    zombie_walk_10.onload = imageLoaded;
    zombie_walk_11.onload = imageLoaded;
    zombie_walk_12.onload = imageLoaded;
    zombie_walk_13.onload = imageLoaded;
    zombie_walk_14.onload = imageLoaded;
    zombie_walk_15.onload = imageLoaded;
    zombie_walk_16.onload = imageLoaded;
    zombie_walk_17.onload = imageLoaded;

    tough_zombie_walk_1.onload = imageLoaded;
    tough_zombie_walk_2.onload = imageLoaded;
    tough_zombie_walk_3.onload = imageLoaded;
    tough_zombie_walk_4.onload = imageLoaded;
    tough_zombie_walk_5.onload = imageLoaded;
    tough_zombie_walk_6.onload = imageLoaded;
    tough_zombie_walk_7.onload = imageLoaded;
    tough_zombie_walk_8.onload = imageLoaded;
    tough_zombie_walk_9.onload = imageLoaded;
    tough_zombie_walk_10.onload = imageLoaded;
    tough_zombie_walk_11.onload = imageLoaded;
    tough_zombie_walk_12.onload = imageLoaded;
    tough_zombie_walk_13.onload = imageLoaded;
    tough_zombie_walk_14.onload = imageLoaded;
    tough_zombie_walk_15.onload = imageLoaded;
    tough_zombie_walk_16.onload = imageLoaded;
    tough_zombie_walk_17.onload = imageLoaded;





    var gun_images = []
    var door_images_list = []
    var door_objects_list = []
    var click_images = []
    var zombie_walk_sprites = []

    function display_click(index)
    {
      screen_ctx.drawImage(click_images[index], 0, 0);
    }

    class class_gun_images
    {
      constructor(standard, shooting1, shooting2)
      {
      this.standard = standard
      this.shooting1 = shooting1
      this.shooting2 = shooting2
      }
    }

    function handle_specific_hud_element(hud_element, hud_element_image , value){
      if (value == "no"){
      hud_element.innerHTML = 0
      hud_element_image.tint_grey
                        }
      else if (value == -1) {
        hud_element.innerHTML = "&#8734;"
      }
      else{
        hud_element_image.untint_grey
        hud_element.innerHTML = value
          }
    }

    function update_hud(){
      hud_health.innerHTML = mi_player.health
      handle_specific_hud_element(hud_pistol , hud_pistol_img, mi_player.weapons[0])
      handle_specific_hud_element(hud_mg , hud_mg_img, mi_player.weapons[1])
      handle_specific_hud_element(hud_shotty , hud_shotty_img, mi_player.weapons[2])
    }

    function imageLoaded() {
      images_loaded++; // Increment the counter for loaded images
      if (images_loaded === num_of_images) {
        // All images have loaded, call your function here
        start_game();
      }
    }


    var enemies = []
    var current_gun_img = gun_img

    // 2 = closed door
    // 3 = open
    // 4 = opening
    if (testing_bool == 0){
    var mini_map = [[1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,1,1],[1,0,0,0,0,0,1,1,1],[1,0,0,1,1,0,1,1,1],[1,1,2,1,0,0,1,1,1],[1,0,0,0,0,0,2,0,1],[1,2,1,1,1,1,1,0,1],[1,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1]]
    }
    else{
      var mini_map = [[1,1,1,1,1],[1,0,0,0,1],[1,2,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]
    }



    var sprites = []

    class sprite
    {
      constructor(image , x , y , id, is_enemy)
      {
        this.x = x
        this.y = y
        this.image = image
        this.id = id
        this.image_width = this.image.width
        this.screen_x = "non"
        console.log("fooooooooooooooooodz", this.image_width)
        this.image_ratio = this.image_width / this.image.height
        this.is_enemy = is_enemy;
        this.normal_dist = "non";
        this.dist_between_player = "non";
        this.player_viewing_angle = 'non'
        this.SPRITE_SCALE = 0.7;
        this.SPRITE_HEIGHT_SHIFT = 0.27
        // this.positioning()
      }

      get_sprite_proj()
      {
        let proj_height = SCREEN_DIST / this.normal_dist * this.SPRITE_SCALE;
        let proj_width = proj_height * this.image_ratio;
//        console.log(proj_width , " =  proj_width = proj_height * this.image_ratio  =  ", proj_height , " * " , this.image_ratio)
        // 27:18 https://www.youtube.com/watch?v=ECqUrT7IdqQ&t=1947s
  //      console.log("bread crum 2");
        let offset = 1; // not sure
        let texture_height = 1;
        let height_shift = 1;
        height_shift = proj_height * this.SPRITE_HEIGHT_SHIFT
    //    console.log(this.screen_x," - ",this.image_width/2)
      //  console.log( main_screen.width / 2," - ",proj_height / 2," + ",height_shift  )
        let x = this.screen_x-(proj_width/2)// - proj_height / 2 + height_shift
        let y = main_screen.height / 2 -( proj_height / 2) + height_shift
//        console.log("x", this.screen_x,"-",(proj_width/2) ,"y" ,main_screen.height / 2 ,"-",( proj_height / 2) ,"+", height_shift, "w " , proj_width ,"h " , proj_height);
                                          //      x                                y                                       w                  h
  //      console.log(" new x  = ", x, "  new  y ", main_screen.height / 2 -( proj_height / 2) + height_shift)
//        screen_ctx.drawImage( this.image ,x , y , proj_width , proj_height );

    //    console.log("saving a sprite ")
        var info = "";
        if (this.is_enemy){info = "a enemy sprite"}else{info = "a object sprite"}
                                                                  //  (image, clip_x="nope", clip_y="nope" ,dx_clip="nope", dy_clip="nope", placing_x="nope", placing_y="nope", resize_width="nope", resize_height="nope" , dist="nope", info = "noooooooope")
        stuff_to_draw_this_frame.push(new a_thing_to_draw_this_frame(this.image ,x , y , proj_width , proj_height , "nope", "nope", "nope", "nope", math.pow( math.pow((mi_player.x - this.x),2)+ math.pow((mi_player.y - this.y),2) , 0.5), info  , this.id))
//        console.log("after saving a sprite ")
      }

      positioning() // get sprite
      {
          let dx = this.x - mi_player.x;
          let dy = this.y - mi_player.y;

          this.player_viewing_angle = math.atan2(dy,dx)
  //        console.log("start of positioning  ",  mi_player.angle , " = mi_player.angle         x - mi_player.x ", this.x , "-" , mi_player.x,  " y - mi_player.y ", this.y , "-" , mi_player.y, "       " , dx, dy ," = dx , dy      " ,this.player_viewing_angle  , "this.player_viewing_angle" )

          let angle_diff = this.player_viewing_angle - mi_player.angle

          if ((dx > 0 && mi_player.angle > math.pi) || (dx < 0 && dy < 0)){console.log("  this if statement ");angle_diff+= (3.1415926535 * 2)}
          let rays_offcentre = angle_diff / DELTA_ANGLE
          this.screen_x = (NUM_RAYS/2 + rays_offcentre) * SCALE
    //      console.log("screen_x = (NUM_RAYS/2 + rays_offcentre)   * SCALE " , (NUM_RAYS/2) , rays_offcentre , SCALE , " angle_diff / DELTA_ANGLE" , angle_diff," / ",DELTA_ANGLE,"  =  " , angle_diff / DELTA_ANGLE)
          this.dist_between_player = math.pow(math.pow(dx, 2) + math.pow(dy,2) , 0.5)
          this.normal_dist = this.dist_between_player * math.cos(angle_diff)
    //      console.log("A    ",angle_diff," = angle_diff   ,  ", DELTA_ANGLE,"  DELTA_ANGLE  ,  ", NUM_RAYS/2 ,"  NUM_RAYS/2  "  , rays_offcentre , "  rays_offcentre  " , SCALE  ,  "  SCALE  ")
//  print(str(delta)+" = delta    ,   "+str(DELTA_ANGLE)+"= DELTA_ANGLE  ,  "+str(HALF_NUM_RAYS)+"= HALF_NUM_RAYS  ,  "+str(delta_rays)+"=delta_rays    ,     "+str(SCALE)+" =  scale ")
      //    console.log("bread crum -1  screenx , screendist, norm dist = " , this.screen_x , SCREEN_DIST , this.normal_dist);
          if ((this.image_width/2< this.screen_x < (SCREEN_DIST + this.image_width/2)) && this.normal_dist > 0.04 && angle_diff < 0.7 && angle_diff > -0.7)
          {
        //    console.log("bread crum");
            this.get_sprite_proj()
          }
          else { console.log("not getting sprite pos");}

      }
    }


    class pickup_object {
        constructor(pickup_type , x , y ){
          this.pickup_range = 0.3;
          this.pickup_type = pickup_type
          this.x = x
          this.y = y
          this.id = pickup_id_counter
          this.score_for_picking_up;

          if (pickup_type == 0){
            this.score_for_picking_up = 50
            var the_image = points_object_image
          }
          if (pickup_type == 1)
          {
            this.score_for_picking_up = 0
            var the_image = floor_mg_image
          }
          this.sprite = new sprite(the_image , x , y , pickup_id_counter , false)
          pickup_id_counter++
        }

      do_stuff(){
        let dx = mi_player.x - this.x
        let dy = mi_player.y - this.y
        if (math.hypot(dy, dx) < this.pickup_range)
        {
          this.picked_up()
        }
      }

      picked_up(){
          if (this.pickup_type == 0 )
          {
            score.innerHTML = parseInt(score.innerHTML)+this.score_for_picking_up
            for (var i = 0; i < pickup_objects.length; i++) {
              if (pickup_objects[i].id == this.id){pickup_objects.splice(i, 1)}
            }
          }


          if (this.pickup_type == 1 )
          {mi_player.pickup(1)
          for (var i = 0; i < pickup_objects.length; i++) {
            if (pickup_objects[i].id == this.id){pickup_objects.splice(i, 1)}
          }

          }
                  }



    }


    class map{
      constructor(the_map)
      {
        console.log("map constructor")
        this.mini_map = the_map
        this.rows = this.mini_map.length
        this.cols = this.mini_map[0].length

      }

      draw_mini_map(){
        console.log("draw mini map  ")
        radar_ctx.beginPath();
        radar_ctx.clearRect(0, 0, radar_canvas.width, radar_canvas.height);
        radar_ctx.fillStyle = "white";
        radar_ctx.fillRect(0, 0 , radar_canvas.width, radar_canvas.height);
        radar_ctx.stroke();
        for (let y = 0; y < this.mini_map.length; y++)
        {
          for (let x = 0; x < this.mini_map[y].length; x++)
          {
            if (this.mini_map[x][y]==1)
                  {
            radar_ctx.fillStyle = "green";
            radar_ctx.fillRect(x*width_of_each_tile, y*height_of_each_tile , width_of_each_tile, height_of_each_tile);
            radar_ctx.stroke();
                  }
            else if (this.mini_map[x][y]==2)
                        {
                  radar_ctx.fillStyle = "blue";
                  radar_ctx.fillRect(x*width_of_each_tile, y*height_of_each_tile , width_of_each_tile, height_of_each_tile);
                  radar_ctx.stroke();
                        }
              else{
                  }
          }
        }
        radar_ctx.closePath();
        radar_ctx.stroke();

        radar_ctx.strokeStyle = "black";
        var player_x = mi_player.x*width_of_each_tile
        var player_y = mi_player.y*height_of_each_tile
        radar_ctx.moveTo(player_x , player_y);
        radar_ctx.lineTo( player_x+2 , player_y+2);
        radar_ctx.stroke();


        radar_ctx.strokeStyle = "blue";
        radar_ctx.fillStyle = "blue";
        for (var pickup_object = 0; pickup_object < pickup_objects.length; pickup_object++) {
          let this_e_x = pickup_objects[pickup_object].x*width_of_each_tile
          let this_e_y = pickup_objects[pickup_object].y*height_of_each_tile
          radar_ctx.beginPath();
          radar_ctx.arc(this_e_x, this_e_y, 1, 0, 2 * math.PI);
          radar_ctx.closePath();
          radar_ctx.stroke();
        }



        radar_ctx.strokeStyle = "red";
        radar_ctx.fillStyle = "red";
        for (var enemy = 0; enemy < enemies.length; enemy++) {
          let this_e_x = enemies[enemy].x*width_of_each_tile
          let this_e_y = enemies[enemy].y*height_of_each_tile
          radar_ctx.beginPath();
          radar_ctx.arc(this_e_x, this_e_y, 1, 0, 2 * math.PI);
          radar_ctx.closePath();
          radar_ctx.stroke();
        }


        radar_ctx.strokeStyle = "black";
        radar_ctx.beginPath();

      }
    }

    var mi_map = new map(mini_map)
    var width_of_each_tile = radar_canvas.width/(mi_map.mini_map.length);
    var height_of_each_tile = radar_canvas.height/(mi_map.mini_map[0].length);



    class player{
      constructor(){
                  this.health = 100;
                  this.selected_weapon = 0;
                  if (testing_bool == 0){
                    this.x = 1.5
                    this.y = 1.5
                    this.angle = 0
                    this.move_speed = 0.03
                    this.rotate_speed =0.05
                    this.weapons = [-1 , "no" , "no"] // -1 = infinite ammo
                  }
                  else{
                    this.x = 1.9
                    this.y = 1.9
                    this.angle = -1.61
                    this.move_speed = 0.03
                    this.rotate_speed =0.05
                    this.weapons = [-1 , "no" , "no"] // -1 = infinite ammo
                  }
                    this.map_pos = [Math.floor(this.x), Math.floor(this.y)]
                   }
      pickup(pickup_type)
      {
        if (pickup_type == 1 || pickup_type == 2)
        {
          var ammo_amount = 0
          if (pickup_type == 1){ammo_amount = 60}// mg
          if (pickup_type == 2){ammo_amount = 12}// shotty
          if (this.weapons[pickup_type] == "no"){this.weapons[pickup_type] = ammo_amount}
          else{
          if (this.weapons[pickup_type] != -1){this.weapons[pickup_type] += ammo_amount}}
        }

      }
      regularizer()
      {

        while (0 > this.angle)
        { console.log("angle too small = ", this.angle)
          this.angle += 6.2831
        }
        while (this.angle > 6.28319)
        {
          console.log("angle too big  = ", this.angle)
          this.angle += -6.2831
        }

      }
      update_map_pos()
      {
        this.map_pos = [Math.floor(this.x), Math.floor(this.y)]
      }
      move(event)
            {


            if (this.angle == 0){this.angle = 0.00001}
            var sin_angle = math.sin(this.angle)
            var cos_angle = math.cos(this.angle)
            var frame_speed = this.move_speed * 1
            console.log("frame speed ",frame_speed)
            var speed_y = frame_speed * sin_angle
            console.log("spped_y ",speed_y)
            console.log(" this.angle " , this.angle)
            var speed_x = frame_speed * cos_angle
            console.log("spped_x ",speed_x)
            var key_code = keycode_pressed
            console.log(key_code)
//            var tile_current = [math.floor(x_hor), math.floor(y_hor)]
              // moving forwards and backwards
            if (key_code == 49)
            {
              this.swap_weapon(0)
            }
            else {
              if(key_code == 50)
              {
                this.swap_weapon(1)
              }
            }
            console.log("next co-ord " ,math.floor(mi_player.x + (speed_x*2)) , math.floor(mi_player.y + (speed_y*2)) , "  or  " , math.floor(mi_player.x - (speed_x*2)) , math.floor(mi_player.y - (speed_y*2)) , " cos pos and speed = ", mi_player.x, mi_player.y, speed_x, speed_y       )
            if (key_code == 37 || key_code == 39 || key_code == 83 || key_code == 87 || key_code == 119|| key_code == 115)
              {
                if ( key_code == 37 || key_code == 87 || key_code == 119) {
                      // w

                      if (mi_map.mini_map[math.floor(mi_player.x + (speed_x*2))][math.floor(mi_player.y + (speed_y*2))]==0 || mi_map.mini_map[math.floor(mi_player.x + (speed_x*2))][math.floor(mi_player.y + (speed_y*2))]==3)
                      {
                        this.y += speed_y
                        this.x += speed_x
                      }

                                                                         }
               if (key_code == 39 || key_code == 83 || key_code == 115) {
                     // s
                     if (mi_map.mini_map[math.floor(mi_player.x - (speed_x*2))][math.floor(mi_player.y - (speed_y*2))]==0  || mi_map.mini_map[math.floor(mi_player.x - (speed_x*2))][math.floor(mi_player.y - (speed_y*2))]==3)
                     {
                     this.y += -speed_y
                     this.x += -speed_x
                     }
                                                                        }
              }
              if (key_code == 32)
                {
                  number_of_times_space_pressed+=1
                  console.log(" zombargar space pressed " , number_of_times_space_pressed)
                  for (var door_id = 0; door_id < door_objects_list.length; door_id++) {
                                if ((mi_map.mini_map[math.floor(mi_player.x + (speed_x*2))][math.floor(mi_player.y + (speed_y*2))]==2   &&   door_objects_list[door_id].x == math.floor(mi_player.x + (speed_x*2)) && door_objects_list[door_id].y == math.floor(mi_player.y + (speed_y*2)))  ||       (mi_map.mini_map[math.floor(mi_player.x + (speed_x*13))][math.floor(mi_player.y + (speed_y*13))]==2   &&   door_objects_list[door_id].x == math.floor(mi_player.x + (speed_x*13)) && door_objects_list[door_id].y == math.floor(mi_player.y + (speed_y*13))))
                                {
                                    door_objects_list[door_id].start_opening()
                                }
                                                                           }
                }


              if (key_code == 113){
                sin_angle = math.sin(this.angle-1.5708);  cos_angle = math.cos(this.angle-1.5708); speed_y = frame_speed * sin_angle; speed_x = frame_speed * cos_angle;
                if (mi_map.mini_map[math.floor(mi_player.x + (speed_x*2))][math.floor(mi_player.y + (speed_y*2))]==0  || mi_map.mini_map[math.floor(mi_player.x + (speed_x*2))][math.floor(mi_player.y + (speed_y*2))]==3)
                {
                this.y += speed_y;  this.x += speed_x
                }
                                  }
              if (key_code == 101){
                sin_angle = math.sin(this.angle+1.5708);  cos_angle = math.cos(this.angle+1.5708); speed_y = frame_speed * sin_angle; speed_x = frame_speed * cos_angle;
                if (mi_map.mini_map[math.floor(mi_player.x + (speed_x*2))][math.floor(mi_player.y + (speed_y*2))]==0  || mi_map.mini_map[math.floor(mi_player.x + (speed_x*2))][math.floor(mi_player.y + (speed_y*2))]==3)
                {
                this.y += speed_y;  this.x += speed_x
                 }
                                    }


              if (key_code == 122)
              {
                if (shooting == 0){
                  console.log("bang 0 ")


                  if (this.weapons[this.selected_weapon] != 0   && this.weapons[this.selected_weapon] != "no")
                  {
                    shooting = 1;
                    var bullet_hit_something = false;
                    if (this.weapons[this.selected_weapon] != -1)
                    {
                      console.log("ammo went from ",this.weapons[this.selected_weapon])
                      this.weapons[this.selected_weapon] += - 1
                      console.log(" to ",this.weapons[this.selected_weapon])
                    }
                    for (var i = 0; i < enemies.length; i++) {
                      if (bullet_hit_something == false){
    //                  console.log("  enemies tttt ", i , enemies[i].id)
                      for(var j = 0; j < stuff_to_draw_this_frame.length; j++){
                        if (stuff_to_draw_this_frame[j].info == "a enemy sprite"){
      //                  console.log("jjjjjjjj")
        //                console.log("stuff to draw this frame init ", j , stuff_to_draw_this_frame[j].id, stuff_to_draw_this_frame[j].info )
                        if (enemies[i].id ==stuff_to_draw_this_frame[j].id){
          //                console.log("ok weve got thing   id = " , enemies[i].id)
                          if (stuff_to_draw_this_frame[j].clip_x < main_screen.width/2 && main_screen.width/2 < stuff_to_draw_this_frame[j].clip_x+stuff_to_draw_this_frame[j].dx_clip)
                                            {
            //                                  console.log(" pppooo x < middle < x+width " , stuff_to_draw_this_frame[j].clip_x , main_screen.width/2 , stuff_to_draw_this_frame[j].clip_x+stuff_to_draw_this_frame[j].dx_clip)
                                              var damage = 10
                                              bullet_hit_something = true;
                                              if(mi_player.selected_weapon == 1){damage = 20}

                                              enemies[i].being_shot(damage)

                                            }
                          else {console.log("not x < middle < x+width " , stuff_to_draw_this_frame[j].clip_x , main_screen.width/2 , stuff_to_draw_this_frame[j].clip_x+stuff_to_draw_this_frame[j].dx_clip)}
                        } else
                        {
              //            console.log(enemies[i].id , stuff_to_draw_this_frame[j].id , "   =   enemies[i].id , stuff_to_draw_this_frame[j].id ")
                        }
                                                                          }
                                                                          else{console.log(stuff_to_draw_this_frame[j].info , " = stuff_to_draw_this_frame[j].info")}
                                                                      }
                                                              }

                                                            }
                                                        }
                        else{this.out_of_ammo()}
                                }
                else if (shooting == 1){
                console.log("allready shooting")
                                       }
              }

              if (key_code == 97 || key_code == 100 || key_code == 65 || key_code == 68)
                {

                  if ( key_code == 97 || key_code == 65){
                        // a
                        this.angle += -this.rotate_speed
                                     }
                 if (key_code == 100 || key_code == 68) {
                       // d
                       this.angle += this.rotate_speed
                                     }
                }

          }

          out_of_ammo()
          {
              out_of_ammo_bool = 1
          }

          swap_weapon(weapon_num)
          {
            console.log("doing a weapon swap init " , weapon_num)
            this.selected_weapon = weapon_num;
            current_gun_img = gun_images[weapon_num].standard
          }

          shoot(){
            // 1 central raycast looking for enemies
          }


    }

var times_update_path_called = 0;

    class a_star_point
    {
      constructor(x , y , parent, target_dist, current_number_of_steps, node_id)
              {
      this.x = x;
      this.y = y;
      this.parent = parent;
      this.target_dist = target_dist;
      this.number_of_steps = current_number_of_steps;
      this.h = math.pow(target_dist,2) + math.pow(this.number_of_steps,0.5)
      this.node_id = node_id
  //    console.log(" weve made a new node,   its x , y and h =" , x , y , this.h , "  its id = ", node_id)
                }
    }

    class a_thing_to_draw_this_frame
      {
        constructor(image, clip_x="nope", clip_y="nope" ,dx_clip="nope", dy_clip="nope", placing_x="nope", placing_y="nope", resize_width="nope", resize_height="nope" , dist="nope", info = "noooooooope" , id = "naaaa")
          {
//              console.log("start of constructor for a thing to draw")
              this.image = image;

              this.clip_x = clip_x
              this.clip_y = clip_y
              this.dx_clip = dx_clip
              this.dy_clip = dy_clip

              this.placing_x = placing_x
              this.placing_y = placing_y
              this.resize_width = resize_width
              this.resize_height = resize_height
              this.id = id
              this.dist = dist

  //            console.log(info)
              this.info = info
    //          console.log(" end  of constructor for a thing to draw")

          }
      }
    function out_of_ammo_draw()
    {
      let chooser = math.random()*4
      if (chooser < 1){display_click(0)}
      else{
        if (chooser < 2){display_click(1)}
        else{
          if (chooser < 3){display_click(2)}
          else{
            if (chooser < 4){display_click(3)}
            else{
            }
          }
        }
      }
    }


    class door{
      constructor(x , y )
      {
        this.x = x
        this.y = y
        this.id = door_object_id_counter
        door_object_id_counter ++
        this.animation_counter = 0
        this.fully_open_counter = 0
        this.open_duration = 500
        this.total_door_opening_time = 50
        this.door_images = door_images_list
        this.door_image_index = 0
        this.frames_per_image = math.floor(this.total_door_opening_time / this.door_images.length)
      }
      get_current_texture()
      {
        return this.door_images[this.door_image_index]
      }
      currently_opening_or_closing_handler()
      {
//        console.log(this.door_images)
  //      console.log("opening, closing handler   =   " , this.animation_counter,this.frames_per_image,this.door_image_index)
        if (mi_map.mini_map[this.x][this.y] == 4)
        {
    //      console.log("ok, this door is trying to open" , this.animation_counter,this.frames_per_image,this.door_image_index)
          // opening below
          if (this.animation_counter > this.frames_per_image)
          {

            this.door_image_index += 1
            this.animation_counter= 0;
          }
          this.animation_counter += 1
          if (this.door_image_index == this.door_images.length-1){mi_map.mini_map[this.x][this.y] = 3; this.animation_counter= 0;}
        }

        else{  //// closing below
          if (mi_map.mini_map[this.x][this.y] == 5){
      //      console.log("ok, this door is trying to close" , this.animation_counter,this.frames_per_image,this.door_image_index)
              if (this.animation_counter > this.frames_per_image)
                  {
                    this.door_image_index += (-1)
                    this.animation_counter= 0;
                  }
                  this.animation_counter += (1)
              if (this.door_image_index == 0){mi_map.mini_map[this.x][this.y] = 2; this.animation_counter= 0;}
                                                    }
      else {
  //      console.log("ok, its propper open " , this.animation_counter,this.frames_per_image,this.door_image_index)
              //  sat open below
        if (mi_map.mini_map[this.x][this.y] == 3) {this.fully_open_counter+=1 ; if(this.fully_open_counter > this.open_duration){this.fully_open_counter = 0; this.try_close_door()}}
          else{console.log(" currently open handler, but not 3 or 4  x , y = ", this.x, this.y , "  map num = " , mi_map.mini_map[this.x][this.y] )}
           }
            }
      }


      try_close_door()
      {
        //var the_door = door_opening[door]
        let player_under_door = false;
        let enemy_under_door = false;
        if (math.floor(mi_player.x)== this.x && math.floor(mi_player.y)== this.y)
        { player_under_door = true}
        enemies.forEach((enemy, i) => {
          if (math.floor(enemy.x)== this.x && math.floor(enemy.y)== this.y)
            { enemy_under_door = true}
        });

        if (player_under_door == false && enemy_under_door == false && mi_map.mini_map[this.x][this.y] == 3)
          {
            this.animation_counter= 0;
            mi_map.mini_map[this.x][this.y] = 5
          }

      }
      start_opening()
      {
    //    console.log("start opening has been called ")
        if (mi_map.mini_map[this.x][this.y]==2){
        mi_map.mini_map[this.x][this.y]=4
              }
        else {
          throw new Error(" trying to open a door at " , this.x , this.y, " which isnt shut, its number on the map is " , mi_map.mini_map[this.x][this.y] , "  the id is   ", this.id)
             }
      }
    }



    class enemy{
      constructor(x , y , idle_sprite_image , walk_sprites){
                    this.health = 10;
                    this.x = x
                    this.y = y
      //              console.log(idle_sprite_image)
                    this.idle_sprite = new sprite(idle_sprite_image , x , y ,enemy_id_counter , true)
                    this.move_speed = 0.001
                    this.rotate_speed =0.27
                    this.map_pos = [Math.floor(this.x), Math.floor(this.y)]
                    this.current_plan = "idle";
                    this.path=[]
    //                console.log("updating path og ")
                    this.update_path_2()
      //              console.log("updated path og ")
                    this.path_recalc_time = 0
                    this.min_attack_dist = 0.25


                    this.walk_sprites = []
                    this.attack_sprites = []

                    for (var i = 0; i < walk_sprites.length; i++) {
                      this.walk_sprites.push(new sprite(walk_sprites[i] , x , y ,enemy_id_counter , true))
                    }

                    this.current_sprite = this.idle_sprite
                    this.frames_per_single_attack_image = 5;
                    this.frames_per_single_walk_image = 5;
                    this.frames_per_attack_animation = this.attack_sprites.length / this.frames_per_single_attack_image
                    this.walk_animation_counter = 0;
                    this.walk_animation_index = 0;
                    this.attack_counter = 0
                    this.damage_per_attack = 10
                    this.score_for_killing = 10;
                    this.id = enemy_id_counter;

                    enemy_id_counter++

                   }

       walk_animation_handler(){
//         console.log("this.walk_animation_counter  ,this.frames_per_single_walk_image ,this.walk_animation_index , this.walk_sprites.length   =    ",this.walk_animation_counter , this.walk_animation_counter , this.frames_per_single_walk_image ,this.walk_animation_index , this.walk_sprites.length)
         this.walk_animation_counter++;
         if (this.walk_animation_counter > this.frames_per_single_walk_image)
           {

             this.walk_animation_counter = 0
             this.walk_animation_index++;
             if (this.walk_animation_index == this.walk_sprites.length)
               {
                 this.walk_animation_index = 0;
                 this.current_sprite = this.walk_sprites[this.walk_animation_index]
               }
  //           console.log(this.current_sprite);
             this.current_sprite = this.walk_sprites[this.walk_animation_index]
    //         console.log(this.current_sprite);
           }


       }



      update_map_pos()
      {
        this.map_pos = [Math.floor(this.x), Math.floor(this.y)]
      }

      being_shot(damage)
      {
          console.log("this.health    =  ", this.health)
          this.health += - damage
          if (this.health < 1)
          {
            score.innerHTML = parseInt(score.innerHTML)+this.score_for_killing
            for (var i = 0; i < enemies.length; i++) {
              if (enemies[i].id == this.id){
                        enemies.splice(i , 1)
                                            }
                                                      }
          }
      }



      update_path_2()
      {
        let number_of_steps = 0
        let found_player = 0
        times_update_path_called++
        let current_node  = new a_star_point(this.x , this.y , "start" , math.hypot((this.x - mi_player.x),(this.y - mi_player.y)), number_of_steps , 0)

        let step_size = 0.1
        let these_posibilities = [];
        let current_index = 0
        let closed = [];
        let good_options = [current_node];
        let rounds_tried = 0
        let node_id_counter = 1;
        while (found_player == 0)
          {
            rounds_tried++;

            let best_h = 99999;
            let this_h = 99999;
            let better_step_found = 0


            current_node = good_options[0]
            current_index = 0


            for (var i = 0; i < good_options.length; i++)
            {
              let this_node = good_options[i]
//              console.log("is  this_node.h < current_node.h   ===   ", this_node.h , " < " , current_node.h ,  "   this x , y " , this_node.x, this_node.y)
              if (this_node.h < current_node.h)
              {
  //              console.log("   we choose this un    " , this_node.node_id)
                current_node = this_node
                current_index = i
              }
            }



//            console.log(rounds_tried ," = rounds_tried    ", current_node.node_id," = id START!!!!!!!!!!!!!!!!  =========   this rounds    current_x , current_y" , current_node.x, current_node.y)
  //          console.log(" REMOVING FROM GOOD LIST COS WERE CURRENTLY ON IT =     x , y , id = ",good_options[current_index].x , good_options[current_index].y , good_options[current_index].id )
            good_options.splice(current_index , 1)
            closed.push(current_node)
            let current_x = current_node.x;
            let current_y = current_node.y;
            these_posibilities = []
            for (var x = -0.1; x < 0.2; x+=step_size)
                    {
                    x = parseFloat(x)
                    let this_x = parseFloat(parseFloat(current_x+x).toFixed(2));
//                    console.log("this_x = ", this_x , "  cos were just rounding current_x+x = " ,  current_x+x)
                    for (var y = -0.1; y < 0.2; y+=step_size)
                          {
                          y = parseFloat(y)
                          let this_y = parseFloat(parseFloat(current_y+y).toFixed(2));
//                          console.log("this_y = ", this_y , "  cos were just rounding current_y+y = " ,  current_y+y)
                          if (mi_map.mini_map[math.floor(this_x)][math.floor(this_y)] == 0 || mi_map.mini_map[math.floor(this_x)][math.floor(this_y)] == 3)
                              {
//                              console.log(" these are walkable x , y = "+(this_x).toString()+" , "+(this_y).toString() , "   it is "  , mi_map.mini_map[math.floor(this_x)][math.floor(this_y)]  ,   "math.floor(this_x) , math.floor(this_y)  =   " ,  math.floor(this_x) , math.floor(this_y))
                              if (x != 0.0 || y !=  0.0){
//                              console.log("x , y arent zero so were cool " , x , y )
                              let this_pont = new a_star_point(this_x, this_y , current_node , math.hypot((this_x - mi_player.x),(this_y - mi_player.y)), current_node.number_of_steps+1 , node_id_counter )
                              node_id_counter ++
                              these_posibilities.push(this_pont);
                                    }
                              else{} //console.log("x , y are zero so skipping " , x , y )}
                              }
                          else {} //console.log(" not moving to    x , y = "+(this_x).toString()+" , "+(this_y).toString()+"   because it is either not walkable or not on the map   it is ", mi_map.mini_map[math.floor(this_x)][math.floor(this_y)])}
                          }
                    }


    /*        for (var i = 0; i < these_posibilities.length; i++)
            {
              console.log("all possibilities shown,  index = ",i,"  x , y  = ",these_posibilities[i].x,these_posibilities[i].y)
            }
    */

            let allready_tried = []
            for (var i = 0; i < these_posibilities.length; i++) {
//              console.log(" a possible next step  =  " , these_posibilities[i].x , these_posibilities[i].y)
                          for (var j = 0; j < closed.length; j++)
                          {
                  //          console.log(" allready closed these  =  " , closed[j].x , closed[j].y)
                            if(closed[j].x == these_posibilities[i].x && closed[j].y == these_posibilities[i].y)
                              {
    //                            console.log("so were not doing this index i = ", i , " so we will be removing " , these_posibilities[i].x , these_posibilities[i].y , "  because closed allready has " , closed[j].x , closed[j].y)
                                allready_tried.push(i)
                              }
                          }
            }

            allready_tried = allready_tried.reverse()
            for (var i = 0; i < allready_tried.length; i++) {
    //          console.log("  so actually removing  = " , these_posibilities[allready_tried[i]].x , these_posibilities[allready_tried[i]].y)
              these_posibilities.splice(allready_tried[i] , 1)
            }

            let allready_in_good_options = []
            for (var i = 0; i < these_posibilities.length; i++) {
  //            console.log(" a possible next step  =  " , these_posibilities[i].x , these_posibilities[i].y)
                          for (var j = 0; j < good_options.length; j++)
                          {
                    //        console.log(" allready got this in good list  =  " , good_options[j].x , good_options[j].y)
                            if(good_options[j].x == these_posibilities[i].x && good_options[j].y == these_posibilities[i].y)
                              {
    //                            console.log("so were not doing this index i = ", i , " so we will be removing " , these_posibilities[i].x , these_posibilities[i].y , "  because good list  allready has " , good_options[j].x , good_options[j].y)
                                allready_in_good_options.push(i)
                              }
                          }
            }

            allready_in_good_options = allready_in_good_options.reverse()
            for (var i = 0; i < allready_in_good_options.length; i++) {
//              console.log("  so actually removing  = " , these_posibilities[allready_in_good_options[i]].x , these_posibilities[allready_in_good_options[i]].y)
              these_posibilities.splice(allready_in_good_options[i] , 1)
            }


            for (var i = 0; i < these_posibilities.length; i++) {
  //            console.log(these_posibilities[i].x , these_posibilities[i].y ,  " x , y          id of a good un = ",these_posibilities[i].node_id)
              good_options.push(these_posibilities[i])
            }

            if ((math.abs(current_node.x - mi_player.x) < step_size)  &&  (math.abs(current_node.y - mi_player.y) < step_size))
            {
    //          console.log("current node is on player  ",current_node.x, "current_node.x  " , current_node.y , "current_node.y" , "    ,    " , " mi_player.x ",  mi_player.x, " mi_player.y ",  mi_player.y , " step_size" , step_size)
              found_player = 1
            }
            if (rounds_tried > 700)
            {
              found_player = 1
              current_node  = new a_star_point("fail" , "fail" , "start" , math.hypot((this.x - mi_player.x),(this.y - mi_player.y)), number_of_steps , 0)

            }
          }
        this.path = []
        console.log("end update path 1")
        if (found_player == 1)
          {
            console.log("end update path 2")
            this.path.push([mi_player.x , mi_player.y])
  //          console.log(" start of complete path ")
            while (current_node.parent != "start")
            {
              console.log("end update path 3")
//              console.log(current_node.parent.x , current_node.parent.y , "    x , y    propper path ")
              this.path.push([current_node.parent.x , current_node.parent.y])
              current_node = current_node.parent;
            }
            this.path.reverse()
          }
      }


      attack()
      {
        this.attack_counter += 1
        if (this.attack_counter > this.frames_per_attack_animation)
        {
          this.attack_counter = 0
          mi_player.health += (-this.damage_per_attack)
        }

      }


      act(){
//        console.log("actys 2 ")
        this.current_sprite.x = this.x
        this.current_sprite.y = this.y

  //      this.sprite.get_sprite_proj()
        for (var i = 0; i < this.path.length; i++) {
  //        console.log(this.path[i] , "  this.path[i]  as acting ")
        }
  //      console.log("actys 3 ")
        this.path_recalc_time  += 1;
        if (this.path_recalc_time > 50)
        {
    //      console.log("recalc_path")
          this.update_path_2();
          this.path_recalc_time = 0;
        }

        let current_attack_dist = math.pow(math.pow((this.x)-(mi_player.x), 2) + math.pow((this.y)-(mi_player.y),2) , 0.5)
        let current_walk_dist = math.pow(math.pow((this.x)-(this.path[0][0]), 2) + math.pow((this.y)-(this.path[0][1]),2) , 0.5)
        //console.log("ere")
      //  console.log("our current x and y = ", this.x , this.y ,"   next x and y  = "  , this.path[0][0], this.path[0][1], "final_target x and y = " , mi_player.x , mi_player.y)

    //    console.log(this.min_attack_dist)
  //      console.log(current_attack_dist)
//        console.log(current_walk_dist)
      //  throw new Error("cease")
//        console.log("actys 3 ")

        if (math.pow(math.pow((this.x)-(this.path[0][0]), 2) + math.pow((this.y)-(this.path[0][1]),2) , 0.5) < this.move_speed * 3)
        {

          this.path.splice(0,1);
  //        console.log("new our current x and y = ", this.x , this.y ,"   next x and y  = "  , this.path[0][0], this.path[0][1], "final_target x and y = " , mi_player.x , mi_player.y)
          current_attack_dist = math.pow(math.pow((this.x)-(mi_player.x), 2) + math.pow((this.y)-(mi_player.y),2) , 0.5)
          current_walk_dist = math.pow(math.pow((this.x)-(this.path[0][0]), 2) + math.pow((this.y)-(this.path[0][1]),2) , 0.5)
    //      console.log("actys 4 ")
        }


  //      console.log(" dese disstys   = " , current_attack_dist , this.min_attack_dist)
        if (current_attack_dist > this.min_attack_dist)
        {
          if (this.path.length > 1){
    //    console.log("walk    current_attack_dist > this.min_attack_dist  = " , current_attack_dist , this.min_attack_dist)




        let dx = this.path[0][0] - this.x
        let dy = this.path[0][1] - this.y
        let angle = math.atan2(dy,dx)

        angle *= 180//3.1415926535
  //      console.log("frigin theta", angle)

//        console.log(angle , "  angle   ")

        whole_message += angle , "  angle   "
    //    console.log('this.path[0][0]' , this.path[0][0],'this.path[0][1]', this.path[0][1])
  //      console.log("eh? 2")
        // angle = acos(dot_product / (magnitude_A * magnitude_B))

        if (angle == 0){angle = 0.00001}

        let sin_angle = math.sin(angle)
        let cos_angle = math.cos(angle)
        let frame_speed = this.move_speed * 1 //dt

        let speed_y = frame_speed * sin_angle
        let speed_x = frame_speed * cos_angle

        this.walk_animation_handler()



      //  console.log("current dx = ", (this.path[0][0] - this.x), " current dy =" , (this.path[0][1] - this.y), "    we get dx from = ", this.path[0][0]," - ",this.x, "    we get dy from = ", this.path[0][1]," - ",this.y)
    //    whole_message += "current dx = ", (this.path[0][0] - this.x), " current dy =" , (this.path[0][1] - this.y), "    we get dx from = ", this.path[0][0]," - ",this.x, "    we get dy from = ", this.path[0][1]," - ",this.y
  ///      console.log("cos bef moving ", cos_angle, "sin bef moving ", sin_angle)
//        whole_message += "cos bef moving ", cos_angle, "sin bef moving ", sin_angle
      //  console.log("speedx bef moving ", speed_x , "speedy bef moving ", speed_y)
    //    whole_message += "speedx bef moving ", speed_x , "speedy bef moving ", speed_y
        this.x+=speed_x
        this.y+=speed_y
        console.log("actys 5")
  //      console.log("this.x after moving ", this.x ,"this.y after moving ", this.y)
//        whole_message += "this.x after moving ", this.x ,"this.y after moving ", this.y
        }
        else
        {
          console.log("no bloody path")
        }
      }
      else{
//        console.log(' actually in range to attack    dist below')
  //      console.log(this.min_attack_dist)
    //    console.log(current_attack_dist)
        this.attack()
          }

      }


      handle_idle()
      {
        if (this.idle_counter < this.idle_counter_limit)
          {
            this.idle_counter+= 1
          }
        else
        {
          this.idle_counter = 0
          random_idle_action_chooser()
        }
      }
      random_idle_action_chooser()
      {
/*        mi_choice = Math.random()*9;
        if (mi_choice < 1){this.current_plan = "idle";}//idle still do nothing
        else if (1 <= mi_choice < 2){this.current_plan = "face_up";}//face up
        else if (2 <= mi_choice < 3){this.current_plan = "face_right";}//face right
        else if (3 <= mi_choice < 4){this.current_plan = "face_down";}//face down
        else if (4 <= mi_choice < 5){this.current_plan = "face_left";}//face left
        else if (5 <= mi_choice < 6){this.current_plan = "move_up_to_"+this.x.toString()+"_"+(this.y-1).toString();}//move up
        else if (6 <= mi_choice < 7){this.current_plan = "move_right";}//move right
        else if (7 <= mi_choice < 8){this.current_plan = "move_down";}//move down
        else if (8 <= mi_choice < 9){this.current_plan = "move_left";}//move left
        this.current_plan = "move_up_to_"+this.x.toString()+"_"+(this.y-1).toString();
      } */
    }
  }

  class tough_enemy extends enemy {
  constructor(x , y , idle_sprite_image , walk_sprites) {
    super(x , y , idle_sprite_image , walk_sprites);
    this.health = 80;
  }
  show() {
    return this.present() + ', it is a ' + this.model;
  }
}

  class item_spawner{

    constructor(spawn_points ){
      this.spawn_points = spawn_points
      this.spawn_probability = 0.005
      this.min_spawn_dist = 4
    }

    spawn_checker(){
      var chooser = math.random()
      if (chooser < this.spawn_probability)
      {
        var chooser = math.random()
        var in_range = []
//        console.log(" item spawner init")
  //      console.log(this.spawn_points)
        for (var i = 0; i < this.spawn_points.length; i++) {
    //      console.log(" item spawn point ", i , "    = " , this.spawn_points[i])
          var sp = this.spawn_points[i];
          if (math.pow(math.pow(sp[0]-mi_player.x, 2) + math.pow(sp[1]-mi_player.y, 2) , 0.5) > this.min_spawn_dist )
          {
            in_range.push(sp)
      //      console.log("added to  in range")
          }
          else{console.log(math.pow(math.pow(sp[0]-mi_player.x, 2) + math.pow(sp[1]-mi_player.y, 2) , 0.5)   , "   =  not > " , this.min_spawn_dist)}
        }
        var spawn_point_index = math.floor(chooser * in_range.length);
        var pickup_type = (Math.random()>0.5)? 1 : 0;
  //      console.log("zoopp"  , pickup_type ,spawn_point_index , chooser ,"*", in_range.length , " = " , in_range , in_range[spawn_point_index])
        var pickup_object1 = new pickup_object( pickup_type , in_range[spawn_point_index][0],in_range[spawn_point_index][1] , zombie_idle , zombie_walk_sprites)
        pickup_objects.push(pickup_object1)
      }
    }
  }





  class spawner{

    constructor(spawn_points ){
      this.spawn_points = spawn_points
      this.spawn_probability = 0.01
      this.tough_spawn_probability = 0.002
      this.min_spawn_dist = 4.
      }

    spawn_checker(){
      var chooser = math.random()
      if (( chooser > this.tough_spawn_probability && chooser < this.spawn_probability) || enemies.length == 0)
      {
        var chooser = math.random()
        var in_range = []
        for (var i = 0; i < this.spawn_points.length; i++) {
          var sp = this.spawn_points[i]; if (math.pow(math.pow(sp[0]-mi_player.x, 2) + math.pow(sp[1]-mi_player.y, 2) , 0.5) > this.min_spawn_dist ) { in_range.push(sp) }
        }
        var spawn_point_index = math.floor(chooser * in_range.length);
        var enemy1 = new enemy( in_range[spawn_point_index][0],in_range[spawn_point_index][1] , zombie_idle , zombie_walk_sprites)
        enemies.push(enemy1)
      }


    if (chooser < this.tough_spawn_probability || enemies.length == 0)
      {
        var chooser = math.random()
        var in_range = []
        for (var i = 0; i < this.spawn_points.length; i++) {
          var sp = this.spawn_points[i]; if (math.pow(math.pow(sp[0]-mi_player.x, 2) + math.pow(sp[1]-mi_player.y, 2) , 0.5) > this.min_spawn_dist ) { in_range.push(sp) }
        }
        var spawn_point_index = math.floor(chooser * in_range.length);
        var enemy1 = new tough_enemy( in_range[spawn_point_index][0],in_range[spawn_point_index][1] , tough_zombie_idle , tough_zombie_walk_sprites)
        enemies.push(enemy1)
      }
    }
  }


    class raycast{
        constructor(){
          this.raycasting_results = []
          this.chunks_of_textures_to_render = []
        }

        get_chunks_of_textures_to_render(raycasting_results , dest_x, dest_y , w , h , x_co_ord_incase_its_a_door, y_co_ord_incase_its_a_door )
        {
          this.chunks_of_textures_to_render = []
    //      for(let ray = 0; ray < raycasting_results.length; ray++)
      //    {
            let dis_ray = raycasting_results
            let depth = dis_ray[0]
            let proj_height  = dis_ray[1]
            let texture  = dis_ray[2]
            let offset  = dis_ray[3]
            let ray  = dis_ray[4]
            let wall_collumn = bricks_texture
        //    console.log("look at the mad fucking texture = ", texture)
            if (texture == 1)
            {
              var wall_texture = bricks_texture
            }
            if (texture == 2){var wall_texture = door_images_list[0]}
            if (texture == 4 || texture == 5)
            {
              for (var i = 0; i < door_objects_list.length; i++) {
                if (door_objects_list[i].x == x_co_ord_incase_its_a_door && door_objects_list[i].y == y_co_ord_incase_its_a_door){ var wall_texture = door_objects_list[i].get_current_texture(); console.log("  door_objects_list[i].get_current_texture(); = " , door_objects_list[i].get_current_texture()); }
              }
            }
/*
            if proj_height < HEIGHT:
                wall_column = self.textures[texture].subsurface(
                    offset * (TEXTURE_SIZE - SCALE), 0, SCALE, TEXTURE_SIZE
                )
                wall_column = pg.transform.scale(wall_column, (SCALE, proj_height))
                print("image clipped starting from = x, y " , offset * (TEXTURE_SIZE - SCALE), 0 , " clipping to " ,SCALE, TEXTURE_SIZE , " being placed at " , ray * SCALE, HALF_HEIGHT - proj_height // 2 , "   and resizing " , SCALE, TEXTURE_SIZE )
                print(" we get pos of clipped x from offset * (TEXTURE_SIZE - SCALE) = " ,  offset , " * (" , TEXTURE_SIZE , " - " , SCALE , ")")
                wall_pos = (ray * SCALE, HALF_HEIGHT - proj_height // 2)
            else:
                texture_height = TEXTURE_SIZE * HEIGHT / proj_height
                wall_column = self.textures[texture].subsurface(
                    offset * (TEXTURE_SIZE - SCALE), HALF_TEXTURE_SIZE - texture_height // 2,
                    SCALE, texture_height
                )
                wall_column = pg.transform.scale(wall_column, (SCALE, HEIGHT))
                print("image clipped starting from = x, y " , offset * (TEXTURE_SIZE - SCALE),  HALF_TEXTURE_SIZE - texture_height // 2 , " clipping to " ,SCALE, HEIGHT , " being placed at " , ray * SCALE, 0 , "   and resizing " , SCALE, HEIGHT )
                print(" we get pos of clipped x from offset * (TEXTURE_SIZE - SCALE) = " ,  offset , " * (" , TEXTURE_SIZE , " - " , SCALE , ")")
                wall_pos = (ray * SCALE, 0)
*/
            if (proj_height < main_screen.height)
            {
              var clip_x = offset * (TEXTURE_SIZE - SCALE)
              var clip_y =  0
              var dx_clip = SCALE
              var dy_clip = TEXTURE_SIZE
              var placing_x = ray * SCALE
              var placing_y = (main_screen.height/2) - proj_height / 2
              var resize_width = SCALE
              var resize_height = proj_height;
    //          console.log(" 1  yhhghgh " , clip_x, clip_y ,dx_clip, dy_clip, placing_x, placing_y, resize_width, resize_height)
            }
            else
            {
              var texture_height = TEXTURE_SIZE * main_screen.height / proj_height
        //      console.log(texture_height, TEXTURE_SIZE , main_screen.height , proj_height)
              var clip_x = offset * (TEXTURE_SIZE - SCALE)
              var clip_y =  HALF_TEXTURE_SIZE - texture_height / 2
              var dx_clip = SCALE
              var dy_clip = texture_height
              var placing_x = ray * SCALE
              var placing_y = 0
              var resize_width = SCALE
              var resize_height = main_screen.height;
  //            console.log(" 2 hgkhghkg ", clip_x, clip_y ,dx_clip, dy_clip, placing_x, placing_y, resize_width, resize_height)
            }


            // drawImage( image, source_x, source_y, w, h, dest_x, dest_y, w, h );

          //  console.log((offset * (TEXTURE_SIZE - SCALE)).toString()+" = source_x , "+math.round(HALF_TEXTURE_SIZE - texture_height / 2).toString()+" = source_y , "+SCALE.toString()+" = SCALE  , "+texture_height.toString()+"  =  texture_height")

      //      throw new Error("buuga lugs")
            // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
//            console.log("image clipped starting from = x, y " , offset * (TEXTURE_SIZE - SCALE), math.round(HALF_TEXTURE_SIZE - texture_height / 2) , " clipping to " ,SCALE, texture_height , " being placed at " , dest_x, dest_y , "   and resizing " , w, h )
  //          console.log(" we get pos of clipped x from offset * (TEXTURE_SIZE - SCALE) = " ,  offset , " * (" , TEXTURE_SIZE , " - " , SCALE , ")")
  //          console.log("zeeeebu")
    //        screen_ctx.drawImage( wall_texture, clip_x, clip_y ,dx_clip, dy_clip, placing_x, placing_y, resize_width, resize_height );
            stuff_to_draw_this_frame.push( new a_thing_to_draw_this_frame(wall_texture, clip_x, clip_y ,dx_clip, dy_clip, placing_x, placing_y, resize_width, resize_height ,  depth , "wall texture" ))
//            screen_ctx.drawImage( wall_texture, offset * (TEXTURE_SIZE - SCALE), math.round(HALF_TEXTURE_SIZE - texture_height / 2) ,SCALE, texture_height, dest_x, dest_y, w, h );

        //  }
//          return wall_collumn;
        }

        ray_cast(){
          this.raycasting_results = []
          var player= mi_player
          var player_x = mi_player.x
          var player_y = mi_player.y
          mi_player.update_map_pos()
          var map_x = mi_player.map_pos[0]
          var map_y = mi_player.map_pos[1]
          var ray_angle = mi_player.angle - HALF_FOV
          let texture_hor = 0;
          let texture_vert = 0;
          var hor_wall_type = 0;
          var vert_wall_type = 0;
          var opening_tile_pos;

          console.log(mi_map.mini_map , " easter ")

          for (let ray = 0; ray < NUM_RAYS; ray++)
                {
                  var opening_depth_vert = 99999
                  var opening_x_vert = 0
                  var opening_y_vert = 0
                  var opening_texture_vert = 0
                  var opening_depth_hor = 99999
                  var opening_x_hor = 0
                  var opening_y_hor = 0
                  var opening_texture_hor = 0
                  var opening_tile_pos_hor = "not set"
                  var opening_tile_pos_vert = "not set"

                  var sin_a = math.sin(ray_angle)
                  var cos_a = math.cos(ray_angle)

                  var opening_door_found = false;

                  if (sin_a > 0){var y_hor = map_y + 1, dy = 1;}
                  else {var y_hor= map_y - 1e-6; dy = -1;}
      //            console.log(y_hor.toString()+" , " +player_y.toString()+" , " +sin_a.toString()+" y_hor , player_y, sin_a")
                  var depth_hor = (y_hor - player_y) / sin_a
                  var x_hor = player_x + depth_hor * cos_a
                  var delta_depth = dy / sin_a
                  var dx = delta_depth * cos_a
        //          console.log(depth_hor.toString()+"  = start   depth_hor     &    start delta_depth  = "+delta_depth.toString())
                  var hit_a_wall = 0
                  var wall_type = 0;
                  screen_ctx.beginPath();
                  for (let ray_bit = 0; ray_bit < MAX_DEPTH; ray_bit++)
                        {
                  //        console.log("ray bit "+ray_bit.toString())
                          var tile_hor = [math.floor(x_hor), math.floor(y_hor)]

                          var found = "nope"
                          for(let this_map_x = 0; this_map_x < mi_map.rows; this_map_x++){
                            for(let this_map_y = 0; this_map_y < mi_map.cols; this_map_y++){
                                      if (tile_hor[0] == this_map_x && tile_hor[1] == this_map_y)
                                                                                {
                                                                                  found = "yep"
                                                                                }
                                                                          }
                                                                        }
                              if (found == "yep"){
                                  if (mi_map.mini_map[tile_hor[0]][tile_hor[1]] == 4 || mi_map.mini_map[tile_hor[0]][tile_hor[1]] == 5)
                                  {
                                    opening_door_found = true;
                                    opening_depth_hor = depth_hor
                                    opening_x_hor = x_hor
                                    opening_y_hor = y_hor
                                    opening_texture_hor = mi_map.mini_map[tile_hor[0]][tile_hor[1]]
                                    opening_tile_pos_hor = [tile_hor[0],tile_hor[1]]


                                    console.log("opening_texture_hor as set  = ", opening_texture_hor)
                                    //
                                  }
                                  if (mi_map.mini_map[tile_hor[0]][tile_hor[1]] ==1 || mi_map.mini_map[tile_hor[0]][tile_hor[1]] ==2){
                                    if (mi_map.mini_map[tile_hor[0]][tile_hor[1]] ==2){}
                                  hor_wall_type = mi_map.mini_map[tile_hor[0]][tile_hor[1]]
                                  texture_hor = mi_map.mini_map[tile_hor[0]][tile_hor[1]];
                        //          console.log("were breaking")
                                  break                                              }
                                  else {}
                                                  }

                          x_hor += dx
                          y_hor += dy
                          depth_hor += delta_depth
                    //      console.log(depth_hor.toString()+"  =   depth_hor= += delta_depth = "+delta_depth.toString())
                        }

                  // verticals
                  //        x_vert, dx = (map_x + 1, 1) if cos_a > 0 else (map_x - 1e-6, -1)

                        if (cos_a > 0){var x_vert = map_x + 1; dx = 1;}
                        else {var x_vert= map_x - 1e-6; dx = -1;}

                        var  depth_vert = (x_vert - player_x) / cos_a
                        var  y_vert = player_y + depth_vert * sin_a

                        var  delta_depth = dx / cos_a
                        var  dy = delta_depth * sin_a
                  //      console.log(depth_vert.toString()+"  = start   depth_vert     &    start delta_depth  = "+delta_depth.toString())


                          for (let ray_bit = 0; ray_bit < MAX_DEPTH; ray_bit++)
                                {

                                  var tile_vert = [math.floor(x_vert), math.floor(y_vert)]
                                  var found = "nope"
                                  for(let this_map_x = 0; this_map_x < mi_map.rows; this_map_x++){
                                    for(let this_map_y = 0; this_map_y < mi_map.cols; this_map_y++){
                                              if (tile_vert[0] == this_map_x && tile_vert[1] == this_map_y)
                                              {found = "yep";}
                                                                                  }
                                                                                }
                                  if (found == "yep"){



                                        if (mi_map.mini_map[tile_vert[0]][tile_vert[1]] == 4  || mi_map.mini_map[tile_vert[0]][tile_vert[1]] == 5)
                                        {
                                          opening_door_found = true;
                                          opening_depth_vert = depth_vert
                                          opening_x_vert = x_vert
                                          opening_y_vert = y_vert
                                          opening_texture_vert = mi_map.mini_map[tile_vert[0]][tile_vert[1]]
                                          opening_tile_pos_vert = [tile_vert[0],tile_vert[1]]
                                          console.log("opening_texture_vert as set  = ", opening_texture_vert)
                                          //
                                        }


                                    if (mi_map.mini_map[tile_vert[0]][tile_vert[1]] ==1 || mi_map.mini_map[tile_vert[0]][tile_vert[1]] ==2){
                                      if (mi_map.mini_map[tile_vert[0]][tile_vert[1]] ==2){}
                                      vert_wall_type = mi_map.mini_map[tile_vert[0]][tile_vert[1]]
                                      texture_vert = mi_map.mini_map[tile_vert[0]][tile_vert[1]];
                                      break                                           }
                                    else {}
                                                    }
                                  x_vert += dx
                                  y_vert += dy
                                  depth_vert += delta_depth
                              //    console.log(depth_vert.toString()+"  =   depth_vert= += delta_depth = "+delta_depth.toString())

                                }


                          if (opening_door_found) {
                            //  throw new Error("opening_depth_vert,opening_x_vert,opening_y_vert,opening_texture_vert  =  ",opening_depth_vert,opening_x_vert,opening_y_vert,opening_texture_vert)
                            if (opening_depth_vert < opening_depth_hor){
                                var opening_wall_type = opening_texture_vert
                                var opening_depth = opening_depth_vert
                          //      console.log(depth.toString()+"  =   depth  = depth vert")
                                var opening_texture = opening_texture_vert
                                opening_y_vert %= 1
                                opening_tile_pos = opening_tile_pos_vert
                                if (cos_a>0){var opening_offset = opening_y_vert; } // console.log(offset.toString()+"  =   offset  =  y vert")}
                                else {var opening_offset = 1-opening_y_vert; } //console.log(offset.toString()+"  =   offset  = 1-y vert")}
                                                          }
                            else{
                                var opening_wall_type = opening_texture_hor
                                var opening_depth = opening_depth_hor
                            //    console.log(depth.toString()+"  =   depth  = depth hor")
                                var opening_texture = opening_texture_hor
                                opening_x_hor %= 1
                                opening_tile_pos = opening_tile_pos_hor
                                if (sin_a>0){var opening_offset =1-opening_x_hor; } //     console.log(offset.toString()+"  =   offset  =  1-x hor") }
                                else {var opening_offset = opening_x_hor; } //console.log(offset.toString()+"  =   offset  =  x hor")}
                              }

                              console.log("opening_texture as set = " , opening_texture)

                          }


                          if (depth_vert < depth_hor){
                              wall_type = vert_wall_type
                              var depth = depth_vert
                        //      console.log(depth.toString()+"  =   depth  = depth vert")
                              var texture = texture_vert
                              y_vert %= 1

                              if (cos_a>0){var offset = y_vert; } // console.log(offset.toString()+"  =   offset  =  y vert")}
                              else {var offset = 1-y_vert; } //console.log(offset.toString()+"  =   offset  = 1-y vert")}
                                                        }
                          else{
                              wall_type = hor_wall_type
                              var depth = depth_hor
                          //    console.log(depth.toString()+"  =   depth  = depth hor")
                              var texture = texture_hor
                              x_hor %= 1

                              if (sin_a>0){var offset =1-x_hor; } //     console.log(offset.toString()+"  =   offset  =  1-x hor") }
                              else {var offset = x_hor; } //console.log(offset.toString()+"  =   offset  =  x hor")}
                            }

                          // remove fishbowl effect
                          depth = depth * math.cos(mi_player.angle - ray_angle)
                      //    console.log(depth.toString()+"  =   depth after multiplying")

                          //projection
                          var proj_height = SCREEN_DIST / (depth + 0.0001)
                          var opening_proj_height = SCREEN_DIST / (opening_depth + 0.0001)



                            var x1 = mi_player.x* width_of_each_tile
                            var x2 = width_of_each_tile*mi_player.x +height_of_each_tile * depth * cos_a



                        //    pg.draw.rect(thescreen, "white" , (math.ceil(ray * SCALE) , math.ceil((HEIGHT//2) - proj_height //2) , math.ceil(SCALE) , math.ceil(proj_height)),2)
                          screen_ctx.strokeStyle = "black";
                          if (wall_type == 1){
                          screen_ctx.rect(math.ceil(ray * SCALE), math.ceil((main_screen.height/2) - proj_height /2) ,math.ceil(SCALE), math.ceil(proj_height));
                          screen_ctx.stroke();
                          }
                          if (wall_type == 2){

                          screen_ctx.strokeStyle = "blue";
                          screen_ctx.rect(math.ceil(ray * SCALE), math.ceil((main_screen.height/2) - proj_height /2) ,math.ceil(SCALE), math.ceil(proj_height));
                          screen_ctx.stroke();
                        }



                          // wtf is texture in this case? cos its not wall type?
                        if (opening_door_found){
                          this.get_chunks_of_textures_to_render([opening_depth , opening_proj_height , opening_texture , opening_offset , ray] ,math.ceil(ray * SCALE), math.ceil((main_screen.height/2) - opening_proj_height /2) ,math.ceil(SCALE), math.ceil(opening_proj_height) , opening_tile_pos[0], opening_tile_pos[1] )
                                                }
                        this.get_chunks_of_textures_to_render([depth , proj_height , texture , offset , ray] , math.ceil(ray * SCALE), math.ceil((main_screen.height/2) - proj_height /2) ,math.ceil(SCALE), math.ceil(proj_height), "not neccesary" , "neccesary, is it neccesary to drink my own urine?")

                        radar_ctx.moveTo(player.x* width_of_each_tile , player.y* height_of_each_tile);
                        radar_ctx.lineTo(width_of_each_tile*player.x +width_of_each_tile * depth * cos_a , height_of_each_tile * player.y +height_of_each_tile * depth * sin_a);
                        radar_ctx.stroke();
                        ray_angle += DELTA_ANGLE


                }

        }

    }


    function handle_shooting()
    {
//      console.log("  mi_player.selected_weapon  arsey mc arsey " , mi_player.selected_weapon)
      if (mi_player.selected_weapon == 0){var gun_shooting_frame_timer1 = 9; var gun_shooting_frame_timer2 = 20}
      else {if (mi_player.selected_weapon == 1){var gun_shooting_frame_timer1 = 2; var gun_shooting_frame_timer2 = 5}}
      gun_fire_counter += 1
  //    console.log("bang 3")
      if (gun_fire_counter < gun_shooting_frame_timer1){current_gun_img = gun_images[mi_player.selected_weapon].shooting1}
      else if(gun_fire_counter > gun_shooting_frame_timer1 - 1 && gun_fire_counter < gun_shooting_frame_timer2 -1){current_gun_img = gun_images[mi_player.selected_weapon].shooting2}
      else {current_gun_img = gun_images[mi_player.selected_weapon].shooting1}
      if (gun_fire_counter > gun_shooting_frame_timer2){shooting = 0; current_gun_img = gun_images[mi_player.selected_weapon].standard; gun_fire_counter = 0; console.log("bang 4")}

    }
//    console.log(" doo doo doo de doo ")
  //  console.log(mini_map)


    function handle_timestamps()
    {
      this_time_stamp = Date.now()
      dt = this_time_stamp - last_time_stamp
      last_time_stamp = Date.now()
    }
    function clear_screen(){
      screen_ctx.beginPath();
      screen_ctx.clearRect(0, 0, main_screen.width, main_screen.height);
      screen_ctx.fillStyle= "white";
      screen_ctx.fillRect(0, 0 , main_screen.width, main_screen.height);
      screen_ctx.stroke();
      screen_ctx.closePath();
//      screen_ctx.beginPath();
    }

    var whole_message = "";

    var the_frame_counter = 0
    var behave;



    function game_loop(){
  /*    for (let y = 0; y < this.mini_map.length; y++)
      {
        for (let x = 0; x < this.mini_map[y].length; x++)
        {
          console.log("this.mini_map[y][x] = " , this.mini_map[y][x] ,"  --    " ,  y , x)
          if (this.mini_map[y][x] == 4){console.log("this.mini_map[y][x] =  444444" , this.mini_map[y][x]);}
        }
      }  */
      update_hud()
//      console.log("9999999999999999=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=yyyyyyyyyyyyyyyyyyyyyyyyyyyy=ttttttttttttttttttt=the_frame_counter    " , the_frame_counter)
  //    console.log(mi_player.selected_weapon , "    mi_player.selected_weapon   ")
    //  whole_message += "9999999999999999=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx=yyyyyyyyyyyyyyyyyyyyyyyyyyyy=ttttttttttttttttttt=the_frame_counter    " , the_frame_counter

      the_frame_counter+= 1
      var key_code_b = keycode_pressed
      mi_player.regularizer()
      console.log('p', key_code_b)
      if (the_frame_counter > 99155  || key_code_b == 112 || times_update_path_called > 98989)
      {
        console.log("behave ")
        console.log(whole_message)

        clearInterval(behave);
      }

      console.log("dead check")
      if (mi_player.health < 1)
      {
        console.log("dead")
        hud_health.innerHTML = " you dead :( "
        game_over_div.style.display = "block"
        clearInterval(behave);
      }
      else{
        console.log("not dead")
        console.log(mi_player)
      }


      clear_screen();
  //    handle_timestamps()

                // positioning()




    //  sprites[0].positioning()
      //sprites[1].positioning()

      $(document).on("keypress", function (event) {
      a_key_pressed = 1
      keycode_pressed = parseInt(event.keyCode)
      })

      if (a_key_pressed==1){mi_player.move(event)}
      stuff_to_draw_this_frame = []
      for (var i = 0; i  < pickup_objects.length; i++) {
          pickup_objects[i].sprite.positioning();
          pickup_objects[i].do_stuff()
      }

//      console.log("actys 0 ")
      for (var enemy = 0; enemy < enemies.length; enemy++) {
  //        console.log("before actys")
    //      console.log(enemies[enemy])
          enemies[enemy].act()
          enemies[enemy].current_sprite.x = enemies[enemy].x
          enemies[enemy].current_sprite.y = enemies[enemy].y
      //    console.log(" after actys")
        //  console.log(enemies[enemy])
          enemies[enemy].current_sprite.positioning();
      }

      mi_map.draw_mini_map();

      raycaster.ray_cast()
      if (shooting == 1)
      {
        handle_shooting()
      }
//      console.log("all enemies")
      for (var i = 0; i < enemies.length; i++) {
  //      console.log(enemies[i])
      }

      door_objects_list.forEach((door) => {
//        console.log("opening, closing handler   =   " , door.animation_counter,door.frames_per_image,door.door_image_index)
        if (mi_map.mini_map[door.x][door.y] == 4 || mi_map.mini_map[door.x][door.y] == 3 || mi_map.mini_map[door.x][door.y] == 5)
        {
          door.currently_opening_or_closing_handler()
        }
      });

      a_key_pressed = 0
      keycode_pressed = "none";

      stuff_to_draw_this_frame_organized_by_dist = []

      for (var i = 0; i < stuff_to_draw_this_frame.length; i++) {
        stuff_to_draw_this_frame_organized_by_dist.push({"stuff":stuff_to_draw_this_frame[i]  , "dist":stuff_to_draw_this_frame[i].dist})
                                                                }

      stuff_to_draw_this_frame_organized_by_dist.sort(function(a,b) {return b.dist - a.dist});
      for (let k in stuff_to_draw_this_frame_organized_by_dist) {
  //        console.log(k , "   k  " , stuff_to_draw_this_frame_organized_by_dist[k].stuff.info)
    //      console.log( typeof  stuff_to_draw_this_frame_organized_by_dist[k].image )
      }
      for (var i = 0; i < stuff_to_draw_this_frame_organized_by_dist.length; i++)
                            {
      //      console.log( typeof  stuff_to_draw_this_frame_organized_by_dist[i].stuff.image )
//            screen_ctx.drawImage( stuff_to_draw_this_frame_organized_by_dist[i].stuff.image ,0,0);
            if (stuff_to_draw_this_frame_organized_by_dist[i].stuff.placing_x == "nope"){screen_ctx.drawImage( stuff_to_draw_this_frame_organized_by_dist[i].stuff.image, stuff_to_draw_this_frame_organized_by_dist[i].stuff.clip_x, stuff_to_draw_this_frame_organized_by_dist[i].stuff.clip_y ,stuff_to_draw_this_frame_organized_by_dist[i].stuff.dx_clip, stuff_to_draw_this_frame_organized_by_dist[i].stuff.dy_clip)}
            else{
            screen_ctx.drawImage( stuff_to_draw_this_frame_organized_by_dist[i].stuff.image, stuff_to_draw_this_frame_organized_by_dist[i].stuff.clip_x, stuff_to_draw_this_frame_organized_by_dist[i].stuff.clip_y ,stuff_to_draw_this_frame_organized_by_dist[i].stuff.dx_clip, stuff_to_draw_this_frame_organized_by_dist[i].stuff.dy_clip, stuff_to_draw_this_frame_organized_by_dist[i].stuff.placing_x, stuff_to_draw_this_frame_organized_by_dist[i].stuff.placing_y, stuff_to_draw_this_frame_organized_by_dist[i].stuff.resize_width, stuff_to_draw_this_frame_organized_by_dist[i].stuff.resize_height );
                }
                            }
      the_spawner.spawn_checker()
      the_item_spawner.spawn_checker()

      screen_ctx.drawImage(current_gun_img, (main_screen.width / 2 - current_gun_img.width / 2)*1.05,  main_screen.height - current_gun_img.height);


      screen_ctx.beginPath();
      // horizontal crosshair
      screen_ctx.lineWidth = 2;
      screen_ctx.strokeStyle = "black";
      screen_ctx.moveTo((main_screen.width/2)-4, (main_screen.height/2));
      screen_ctx.lineTo((main_screen.width/2)+4, (main_screen.height/2));
      // vertical crosshair
      screen_ctx.moveTo((main_screen.width/2), (main_screen.height/2)-4);
      screen_ctx.lineTo((main_screen.width/2), (main_screen.height/2)+4);
      screen_ctx.stroke();
      screen_ctx.lineWidth = 1;

      if (out_of_ammo_bool == 1)
      {
        out_of_ammo_draw()
        out_of_ammo_bool = 0
      }

  }

  function reset(){
    game_over_div.style.display="none"
    enemies = []
    pickup_objects = []
    door_objects_list = []
    start_game()
    behave = setInterval(game_loop, 30);
  }

  function start_game() {
    mi_map = new map(mini_map)
    console.log(mi_map.mini_map)
    mi_player = new player()
    console.log(mi_map.mini_map)
    raycaster = new raycast()
    console.log(mi_map.mini_map)
    mi_map.draw_mini_map();
    raycaster.ray_cast()
    console.log(mi_map.mini_map)
    console.log(" doo doo doo de de , de doo de de , de doo ")
    var this_time_stamp = Date.now()
    var last_time_stamp = Date.now()


    click_images = [click_img_1,click_img_2,click_img_3,click_img_4]
    door_images_list = [door1_image,door2_image,door3_image,door4_image,door5_image,door6_image,door7_image,door8_image,door9_image,door10_image,door11_image]
    zombie_walk_sprites = [zombie_walk_1, zombie_walk_2, zombie_walk_3, zombie_walk_4, zombie_walk_5, zombie_walk_6, zombie_walk_7, zombie_walk_8, zombie_walk_9 , zombie_walk_10,zombie_walk_11, zombie_walk_12, zombie_walk_13, zombie_walk_14, zombie_walk_15, zombie_walk_16, zombie_walk_17]
    tough_zombie_walk_sprites = [tough_zombie_walk_1, tough_zombie_walk_2, tough_zombie_walk_3, tough_zombie_walk_4, tough_zombie_walk_5, tough_zombie_walk_6, tough_zombie_walk_7, tough_zombie_walk_8, tough_zombie_walk_9 , tough_zombie_walk_10,tough_zombie_walk_11, tough_zombie_walk_12, tough_zombie_walk_13, tough_zombie_walk_14, tough_zombie_walk_15, tough_zombie_walk_16, tough_zombie_walk_17]


    for (var x = 0; x < mi_map.mini_map.length; x++) {
      for (var y = 0; y < mi_map.mini_map[x].length; y++) {
        if (mi_map.mini_map[x][y]==2) {
          door_objects_list.push(new door(x,y))
        }
      }
    }



    if (testing_bool){
    test_enemy = new enemy( 3.1,3.1 , zombie_idle , zombie_walk_sprites)
    test_enemy2 = new enemy( 3.2,3.2 , zombie_idle , zombie_walk_sprites)
    test_enemy3 = new enemy( 3.3,3.3 , zombie_idle , zombie_walk_sprites)
    test_enemy4 = new enemy( 3.4,3.4 , zombie_idle , zombie_walk_sprites)
    test_enemy5 = new enemy( 3.4,1.4 , zombie_idle , zombie_walk_sprites)
    test_enemy6 = new enemy( 3.5,1.5 , zombie_idle , zombie_walk_sprites)
    the_spawner = new spawner([[3.1,3.1],[3.2,3.2],[3.3,3.3],[3.4,3.4],[3.5,3.5],[3.6,3.6],[3.5,1.8] ,[1.4,1.3]  , [1.2, 3.4]])
//    the_item_spawner = new item_spawner([1.5,1.5], [3.5,1.5], [3.5,2.5],[1.1,2.1],[1.4,2.1],[1.1,2.4],[1.1,3.9],[1.1,4.1],[1.1,5.9],[2.5,5.9],[3.5,5.9],[4.5,5.9],[5.9,5.9],[4.1,4.1],[7.1,4.1],[7.6,1.1])
    enemies.push(test_enemy)
    enemies.push(test_enemy2)
    enemies.push(test_enemy3)
    enemies.push(test_enemy4)
    pickup_objects.push( new pickup_object(1 , 1.5 , 3.5))
    pickup_objects.push( new pickup_object(1 , 1.4 , 3.5))
    pickup_objects.push( new pickup_object(1 , 1.5 , 3.4))
  }
  else{
    the_spawner = new spawner([[1.1,3.1],[1.2,2.2],[4.3,1.3],[3.4,5.4],[1.5,5.5],[5.6,3.6],[7.5,7.8], [5.5,5.5] , [4.8 , 4.8], [4.4 , 4.6]])
    the_item_spawner = new item_spawner([[1.5,1.5], [3.5,1.5], [3.5,2.5],[1.1,2.1],[1.4,2.1],[1.1,2.4],[1.1,3.9],[1.1,4.1],[1.1,5.9],[2.5,5.9],[3.5,5.9],[4.5,5.9],[5.9,5.9],[4.1,4.1],[7.1,4.1],[7.6,1.1]])
    test_enemy = new enemy( 7.5, 7.8 , zombie_idle , zombie_walk_sprites)
    enemies.push(test_enemy)
  }
//    enemies.push(test_enemy5)
  //  enemies.push(test_enemy6)

    gun_images.push(new class_gun_images(pistol_img, shooting_1_pistol_img, shooting_2_pistol_img))
    gun_images.push(new class_gun_images(mg_img, shooting_1_mg_img, shooting_2_mg_img))

    behave = setInterval(game_loop, 30);
//    console.log("we broke art of the game loop ")
    if (behave) {
  //    console.log("well we actually did fucing die ")
      hud_health.innerHTML = " you dead :( "
    }
  }
//    console.log("well we actually did fucing die  2 behave ")
  //  console.log(whole_message)
//  })

  </script>
</html>
